name: Deploy Account API

on:
  push:
    paths:
      - 'configs/deployments.json'
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Parse deployment configuration
      id: config
      run: |
        if [ -f "configs/deployments.json" ]; then
          # Parse the JSON array and get the first deployment
          APP_NAME=$(jq -r '.[0].application_name' configs/deployments.json)
          ENVIRONMENT=$(jq -r '.[0].environment' configs/deployments.json)
          REGION=$(jq -r '.[0].region' configs/deployments.json)
          VERSION=$(jq -r '.[0].version' configs/deployments.json)
          APPROVED_BY=$(jq -r '.[0].approved_by' configs/deployments.json)
          
          echo "application_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "region=$REGION" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "approved_by=$APPROVED_BY" >> $GITHUB_OUTPUT
          
          echo "ğŸš€ Deployment triggered!"
          echo "ğŸ“¦ Application: $APP_NAME"
          echo "ğŸŒ Environment: $ENVIRONMENT"
          echo "ğŸ“ Region: $REGION"
          echo "ğŸ·ï¸ Version: $VERSION"
          echo "ğŸ‘¤ Approved by: $APPROVED_BY"
          echo "â° Timestamp: $(date)"
        else
          echo "âŒ No deployment configuration found"
          exit 1
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ steps.config.outputs.region }}
        role-session-name: GitHubActions-${{ github.run_id }}

    - name: Verify AWS credentials
      run: |
        aws sts get-caller-identity
        echo "âœ… AWS credentials configured successfully"

    - name: Check existing infrastructure
      id: infra-check
      run: |
        # Check if ECS cluster exists
        CLUSTER_NAME="${{ steps.config.outputs.application_name }}-${{ steps.config.outputs.environment }}-cluster"
        SERVICE_NAME="${{ steps.config.outputs.application_name }}-${{ steps.config.outputs.environment }}-service"
        
        if aws ecs describe-clusters --clusters $CLUSTER_NAME --region ${{ steps.config.outputs.region }} --query 'clusters[0].status' --output text | grep -q ACTIVE; then
          echo "âœ… ECS cluster exists: $CLUSTER_NAME"
          echo "cluster_exists=true" >> $GITHUB_OUTPUT
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
        else
          echo "âŒ ECS cluster not found: $CLUSTER_NAME"
          echo "cluster_exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ steps.config.outputs.application_name }}
        IMAGE_TAG: ${{ steps.config.outputs.version }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region ${{ steps.config.outputs.region }} || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region ${{ steps.config.outputs.region }} --image-scanning-configuration scanOnPush=true
        
        # Build image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        
        # Push to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Also tag as latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output the image URI
        echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "ğŸ³ Docker image built and pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Update ECS service (App-only deployment)
      run: |
        echo "ğŸ”„ Updating ECS service with new image..."
        
        # Get current task definition
        TASK_DEF_ARN=$(aws ecs describe-services \
          --cluster ${{ steps.infra-check.outputs.cluster_name }} \
          --services ${{ steps.infra-check.outputs.service_name }} \
          --region ${{ steps.config.outputs.region }} \
          --query 'services[0].taskDefinition' --output text)
        
        echo "ğŸ“‹ Current task definition: $TASK_DEF_ARN"
        
        # Get task definition details
        aws ecs describe-task-definition \
          --task-definition $TASK_DEF_ARN \
          --region ${{ steps.config.outputs.region }} \
          --query 'taskDefinition' > current-task-def.json
        
        # Update the image in task definition
        jq --arg IMAGE "${{ steps.build-image.outputs.image_uri }}" \
           '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
           current-task-def.json > new-task-def.json
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://new-task-def.json \
          --region ${{ steps.config.outputs.region }} \
          --query 'taskDefinition.taskDefinitionArn' --output text)
        
        echo "ğŸ“‹ New task definition: $NEW_TASK_DEF_ARN"
        
        # Update service with new task definition
        aws ecs update-service \
          --cluster ${{ steps.infra-check.outputs.cluster_name }} \
          --service ${{ steps.infra-check.outputs.service_name }} \
          --task-definition $NEW_TASK_DEF_ARN \
          --region ${{ steps.config.outputs.region }}
        
        echo "âœ… ECS service update initiated"

    - name: Wait for deployment to complete
      run: |
        echo "â³ Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ steps.infra-check.outputs.cluster_name }} \
          --service ${{ steps.infra-check.outputs.service_name }} \
          --region ${{ steps.config.outputs.region }} \
          --cli-read-timeout 600 \
          --cli-connect-timeout 60

    - name: Get load balancer URL
      id: lb-url
      run: |
        # Try to get load balancer URL from ECS service
        LB_ARN=$(aws ecs describe-services \
          --cluster ${{ steps.infra-check.outputs.cluster_name }} \
          --services ${{ steps.infra-check.outputs.service_name }} \
          --region ${{ steps.config.outputs.region }} \
          --query 'services[0].loadBalancers[0].targetGroupArn' --output text)
        
        if [ "$LB_ARN" != "None" ] && [ "$LB_ARN" != "" ]; then
          # Get load balancer ARN from target group
          LB_ARN=$(aws elbv2 describe-target-groups \
            --target-group-arns $LB_ARN \
            --region ${{ steps.config.outputs.region }} \
            --query 'TargetGroups[0].LoadBalancerArns[0]' --output text)
          
          # Get load balancer DNS name
          LB_URL=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns $LB_ARN \
            --region ${{ steps.config.outputs.region }} \
            --query 'LoadBalancers[0].DNSName' --output text)
          
          echo "load_balancer_url=http://$LB_URL" >> $GITHUB_OUTPUT
        else
          echo "load_balancer_url=Not configured" >> $GITHUB_OUTPUT
        fi

    - name: Deployment summary
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸ“¦ Application: ${{ steps.config.outputs.application_name }}"
        echo "ğŸŒ Environment: ${{ steps.config.outputs.environment }}"
        echo "ğŸ“ Region: ${{ steps.config.outputs.region }}"
        echo "ğŸ·ï¸ Version: ${{ steps.config.outputs.version }}"
        echo "ğŸ‘¤ Approved by: ${{ steps.config.outputs.approved_by }}"
        echo "ğŸŒ Load Balancer URL: ${{ steps.lb-url.outputs.load_balancer_url }}"
        echo "ğŸ”— ECS Cluster: ${{ steps.infra-check.outputs.cluster_name }}"
        echo "âš™ï¸ ECS Service: ${{ steps.infra-check.outputs.service_name }}"
        echo "ğŸ³ Docker Image: ${{ steps.build-image.outputs.image_uri }}"
        echo "âœ… Deployment Status: SUCCESS"
        echo ""
        echo "ğŸ”— Quick Links:"
        echo "   AWS ECS Console: https://console.aws.amazon.com/ecs/home?region=${{ steps.config.outputs.region }}#/clusters/${{ steps.infra-check.outputs.cluster_name }}/services"
        echo "   Application URL: ${{ steps.lb-url.outputs.load_balancer_url }}"