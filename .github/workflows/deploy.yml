name: Deploy Account API

on:
  push:
    paths:
      - 'configs/deployments.json'
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
  TF_VERSION: 1.5.0

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Parse deployment configuration
      id: config
      run: |
        if [ -f "configs/deployments.json" ]; then
          # Parse the JSON array and get the first deployment
          APP_NAME=$(jq -r '.[0].application_name' configs/deployments.json)
          ENVIRONMENT=$(jq -r '.[0].environment' configs/deployments.json)
          REGION=$(jq -r '.[0].region' configs/deployments.json)
          VERSION=$(jq -r '.[0].version' configs/deployments.json)
          APPROVED_BY=$(jq -r '.[0].approved_by' configs/deployments.json)
          
          echo "application_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "region=$REGION" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "approved_by=$APPROVED_BY" >> $GITHUB_OUTPUT
          
          echo "ğŸš€ Deployment triggered!"
          echo "ğŸ“¦ Application: $APP_NAME"
          echo "ğŸŒ Environment: $ENVIRONMENT"
          echo "ğŸ“ Region: $REGION"
          echo "ğŸ·ï¸ Version: $VERSION"
          echo "ğŸ‘¤ Approved by: $APPROVED_BY"
          echo "â° Timestamp: $(date)"
        else
          echo "âŒ No deployment configuration found"
          exit 1
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ steps.config.outputs.region }}
        role-session-name: GitHubActions-${{ github.run_id }}

    - name: Verify AWS credentials
      run: |
        aws sts get-caller-identity
        echo "âœ… AWS credentials configured successfully"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ steps.config.outputs.application_name }}
        IMAGE_TAG: ${{ steps.config.outputs.version }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region ${{ steps.config.outputs.region }} || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region ${{ steps.config.outputs.region }} --image-scanning-configuration scanOnPush=true
        
        # Build image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        
        # Push to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # Also tag as latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Output the image URI for Terraform
        echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Init
      working-directory: ./infra
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
          -backend-config="key=${{ steps.config.outputs.application_name }}/${{ steps.config.outputs.environment }}/${{ steps.config.outputs.region }}/terraform.tfstate" \
          -backend-config="region=${{ steps.config.outputs.region }}"

    - name: Import existing AWS resources
      working-directory: ./infra
      run: |
        echo "ğŸ”§ Importing existing AWS resources to avoid conflicts..."
        chmod +x import-existing-resources.sh
        
        # Set environment variables for the import script
        export APPLICATION_NAME="${{ steps.config.outputs.application_name }}"
        export ENVIRONMENT="${{ steps.config.outputs.environment }}"
        export REGION="${{ steps.config.outputs.region }}"
        
        # Run import script (will handle errors gracefully)
        ./import-existing-resources.sh || echo "âš ï¸ Some imports failed, but continuing with deployment..."

    - name: Terraform Plan
      working-directory: ./infra
      run: |
        terraform plan \
          -var="application_name=${{ steps.config.outputs.application_name }}" \
          -var="environment=${{ steps.config.outputs.environment }}" \
          -var="aws_region=${{ steps.config.outputs.region }}" \
          -var="docker_image=${{ steps.build-image.outputs.image_uri }}" \
          -out=tfplan

    - name: Terraform Apply
      working-directory: ./infra
      run: |
        terraform apply -auto-approve tfplan

    - name: Get deployment outputs
      working-directory: ./infra
      id: outputs
      run: |
        LOAD_BALANCER_URL=$(terraform output -raw load_balancer_url 2>/dev/null || echo "")
        ECS_CLUSTER=$(terraform output -raw ecs_cluster_name 2>/dev/null || echo "")
        ECS_SERVICE=$(terraform output -raw ecs_service_name 2>/dev/null || echo "")
        
        echo "load_balancer_url=$LOAD_BALANCER_URL" >> $GITHUB_OUTPUT
        echo "ecs_cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
        echo "ecs_service=$ECS_SERVICE" >> $GITHUB_OUTPUT

    - name: Wait for deployment to complete
      run: |
        echo "â³ Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ steps.outputs.ecs_cluster }} \
          --service ${{ steps.outputs.ecs_service }} \
          --region ${{ steps.config.outputs.region }}

    - name: Deployment summary
      run: |
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸ“¦ Application: ${{ steps.config.outputs.application_name }}"
        echo "ğŸŒ Environment: ${{ steps.config.outputs.environment }}"
        echo "ğŸ“ Region: ${{ steps.config.outputs.region }}"
        echo "ğŸ·ï¸ Version: ${{ steps.config.outputs.version }}"
        echo "ğŸ‘¤ Approved by: ${{ steps.config.outputs.approved_by }}"
        echo "ğŸŒ Load Balancer URL: ${{ steps.outputs.load_balancer_url }}"
        echo "ğŸ”— ECS Cluster: ${{ steps.outputs.ecs_cluster }}"
        echo "âš™ï¸ ECS Service: ${{ steps.outputs.ecs_service }}"
        echo "ğŸ³ Docker Image: ${{ steps.build-image.outputs.image_uri }}"
        echo "âœ… Deployment Status: SUCCESS"